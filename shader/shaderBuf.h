#pragma once

#define simple_vert "#version 450\r\n\r\nlayout (location = 1) in vec2 aPosition;\r\n\r\nuniform float aspect;\r\n\r\nvoid main() {\r\n    vec2 position = aPosition;\r\n    if (aspect > 1.0f)\r\n        position.x /= aspect;\r\n    else\r\n        position.y *= aspect;\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n}"

#define simple_frag "#version 450\r\n\r\nout vec4 FragColor;\r\n\r\nuniform vec4 myColor;\r\n\r\nvoid main() {\r\n    FragColor = myColor;\r\n}"

#define model_vert "#version 450\r\n\r\nlayout (location = 1) in vec3 aPosition;\r\nlayout (location = 2) in vec3 aNormal;\r\nlayout (location = 3) in vec2 aTexCoord;\r\n\r\nout VS_OUT {\r\n    vec3 position;\r\n    vec3 normal;\r\n    vec2 texCoord;\r\n} vs_out;\r\n\r\nuniform mat4 gWorld;\r\nuniform mat4 gRot;\r\n\r\nvoid main() {\r\n    mat4 gWorld_T = transpose(gWorld);\r\n    mat4 gRot_T = transpose(gRot);\r\n    vs_out.position = vec3((gWorld_T * vec4(aPosition, 1.0f)).xyz);\r\n    vs_out.normal = vec3(normalize((gRot_T * vec4(aNormal, 1.0f)).xyz));\r\n    vs_out.texCoord = aTexCoord;\r\n}"

#define model_frag "#version 450\r\n\r\nin GS_OUT {\r\n    vec3 position;\r\n    vec3 normal;\r\n    vec2 texCoord;\r\n} fs_in;\r\n\r\nout vec4 FragColor;\r\n\r\nuniform int gUseTex;\r\nuniform sampler2D gSampler;\r\n\r\nvec4 gRawColor = vec4(0.44f, 0.57f, 0.75f, 1.0f);\r\nvec3 gEyePosition = vec3(0.0f, 0.0f, -3.0f);\r\nvec3 gPointLightColor = vec3(1.0f, 1.0f, 1.0f);\r\nvec3 gPointLightPosition = vec3(-0.3f, 0.7f, -3.0f);\r\nfloat gAmbientLight = 0.6f;\r\nfloat gDiffuseIntensity = 0.8f;\r\nfloat gSpecularIntensity = 0.8f;\r\nfloat gSpecularPower = 8.0f;\r\nfloat gConstant = 1.2f;\r\nfloat gLinear = 0.6f;\r\nfloat gExp = 0.2f;\r\n\r\nvec4 calcAmbientLight(float light) {\r\n    return vec4(vec3(gAmbientLight), 1.0f);\r\n}\r\n\r\nvec4 calcDiffuseLight(vec3 color, vec3 direction, float intensity) {\r\n    float factor = dot(normalize(fs_in.normal), normalize(-direction));\r\n    if (factor > 0) {\r\n        return vec4(color * intensity * factor, 1.0f);\r\n    } else {\r\n        return vec4(vec3(0.0f), 1.0f);\r\n    }\r\n}\r\n\r\nvec4 calcSpecularLight(vec3 color, vec3 direction, vec3 eyePosition, float intensity, float power) {\r\n    float sign = dot(fs_in.normal, -direction);\r\n    if (sign > 0) {\r\n        vec3 vertexToEye = normalize(eyePosition - fs_in.position);\r\n        vec3 reflection = normalize(reflect(direction, fs_in.normal));\r\n        float factor = dot(vertexToEye, reflection);\r\n        if (factor > 0) {\r\n            factor = pow(factor, power);\r\n            return vec4(color * intensity * factor, 1.0f);\r\n        } else {\r\n            return vec4(vec3(0.0f), 1.0f);\r\n        }\r\n    }\r\n    return vec4(vec3(0.0f), 1.0f);\r\n}\r\n\r\nvec4 calcPointLight(vec3 color, vec3 position) {\r\n    vec3 lightDirection = fs_in.position - position;\r\n    float distance = length(lightDirection);\r\n    vec4 ambientLight = calcAmbientLight(gAmbientLight);\r\n    vec4 diffuseLignt = calcDiffuseLight(color, lightDirection, gDiffuseIntensity);\r\n    vec4 specularLight = calcSpecularLight(color, lightDirection, gEyePosition, gSpecularIntensity, gSpecularPower);\r\n    float attenutation = gConstant + gLinear * distance + gExp * distance * distance;\r\n    return ambientLight + (diffuseLignt + specularLight) / attenutation;\r\n}\r\n\r\nvoid main() {\r\n    vec4 light = calcPointLight(gPointLightColor, gPointLightPosition);\r\n    if (gUseTex == 1) {\r\n        FragColor = vec4(texture2D(gSampler, fs_in.texCoord.xy) * light);\r\n    } else {\r\n        FragColor = vec4(gRawColor * light);\r\n    }\r\n}"

#define model_tcs "#version 450\n\nlayout (vertices = 4) out;\n\nin VS_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} tcs_in[];\n\nout TCS_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} tcs_out[];\n\nvec3 gEyePosition = vec3(0.0f, 0.0f, -3.0f);\n\nfloat calcDistance(vec3 a, vec3 b) {\n    vec3 diff = a - b;\n    return sqrt(dot(diff, diff));\n}\n\nvoid main() {\n    float dist1 = calcDistance(tcs_in[0].position, gEyePosition);\n    float dist2 = calcDistance(tcs_in[1].position, gEyePosition);\n    float dist3 = calcDistance(tcs_in[2].position, gEyePosition);\n    float dist4 = calcDistance(tcs_in[3].position, gEyePosition);\n\n    float n_dist1 = (dist1 + dist2) / 2.0f;\n    float n_dist2 = (dist2 + dist3) / 2.0f;\n    float n_dist3 = (dist3 + dist4) / 2.0f;\n    float n_dist4 = (dist4 + dist1) / 2.0f;\n\n    float n_total = (n_dist1 + n_dist3) / 2.0f;\n\n//    gl_TessLevelInner[0] = 1.0f;\n//    gl_TessLevelInner[1] = 1.0f;\n//\n//    gl_TessLevelOuter[0] = 1.0f;\n//    gl_TessLevelOuter[1] = 1.0f;\n//    gl_TessLevelOuter[2] = 1.0f;\n//    gl_TessLevelOuter[3] = 1.0f;\n\n    gl_TessLevelInner[0] = max(3.0f - n_total / 3.0f, 1.0f);\n    gl_TessLevelInner[1] = max(3.0f - n_total / 3.0f, 1.0f);\n\n    gl_TessLevelOuter[0] = max(3.0f - n_dist2 / 3.0f, 1.0f);\n    gl_TessLevelOuter[1] = max(3.0f - n_dist3 / 3.0f, 1.0f);\n    gl_TessLevelOuter[2] = max(3.0f - n_dist4 / 3.0f, 1.0f);\n    gl_TessLevelOuter[3] = max(3.0f - n_dist1 / 3.0f, 1.0f);\n\n    tcs_out[gl_InvocationID].position = tcs_in[gl_InvocationID].position;\n    tcs_out[gl_InvocationID].normal = tcs_in[gl_InvocationID].normal;\n    tcs_out[gl_InvocationID].texCoord = tcs_in[gl_InvocationID].texCoord;\n}"

#define model_tes "#version 450\n\nlayout(quads, equal_spacing, ccw) in;\n\nin TCS_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} tes_in[];\n\nout TES_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} tes_out;\n\nvec3 calcVertex2(vec3 v1, vec3 n1, vec3 v2, vec3 n2) {\n    if (length(n1 - n2) < 1e-6 || dot(v2 - v1, n1) * dot(v2 - v1, n2) > -1e-6) {\n        return (v1 + v2) / 2.0f;\n    }\n    vec3 avg = (n1 + n2) / 2.0f;\n    mat3 mat_left = transpose(mat3(n1, n2, cross(v2 - v1, avg)));\n    vec3 vec_right = vec3(dot(v1, n1), dot(v2, n2), dot(cross(v1, v2), avg));\n    return inverse(mat_left) * vec_right;\n}\n\nvec3 calcVertex3(vec3 v1, vec3 n1, vec3 v2, vec3 n2, vec3 v3, vec3 n3) {\n    if (length(n2 - n3) < 1e-6 || dot(v3 - v2, n2) * dot(v3 - v2, n3) > -1e-6) {\n        return calcVertex2(v1, n1, v2, n2) + (v3 - v2) / 2.0f;\n    }\n    mat3 mat_left = mat3(n1, n2, n3);\n    vec3 vec_right = vec3(dot(v1, n1), dot(v2, n2), dot(v3, n3));\n    return vec_right * inverse(mat_left);\n}\n\nvec3 calcBezierSample3(vec3 v1, vec3 v2, vec3 v3, float t) {\n    float rt = 1.0f - t;\n    vec3 vert1 = t * v1 + rt * v2;\n    vec3 vert2 = t * v2 + rt * v3;\n    return t * vert1 + rt * vert2;\n}\n\nvoid main() {\n    float u = gl_TessCoord.x;\n    float ru = 1 - u;\n    float v = gl_TessCoord.y;\n    float rv = 1 - v;\n\n    tes_out.normal =\n    u * v * tes_in[0].normal +\n    ru * v * tes_in[1].normal +\n    ru * rv * tes_in[2].normal +\n    u * rv * tes_in[3].normal;\n\n    tes_out.texCoord =\n    u * v * tes_in[0].texCoord +\n    ru * v * tes_in[1].texCoord +\n    ru * rv * tes_in[2].texCoord +\n    u * rv * tes_in[3].texCoord;\n\n//    tes_out.position =\n//    u * v * tes_in[0].position +\n//    ru * v * tes_in[1].position +\n//    ru * rv * tes_in[2].position +\n//    u * rv * tes_in[3].position;\n\n    vec3[3][3] vertices;\n\n    vertices[0][0] = tes_in[3].position;\n    vertices[0][2] = tes_in[2].position;\n    vertices[2][0] = tes_in[0].position;\n    vertices[2][2] = tes_in[1].position;\n\n    vertices[2][1] = calcVertex2(tes_in[0].position, tes_in[0].normal, tes_in[1].position, tes_in[1].normal);\n    vertices[1][2] = calcVertex2(tes_in[1].position, tes_in[1].normal, tes_in[2].position, tes_in[2].normal);\n    vertices[0][1] = calcVertex2(tes_in[2].position, tes_in[2].normal, tes_in[3].position, tes_in[3].normal);\n    vertices[1][0] = calcVertex2(tes_in[3].position, tes_in[3].normal, tes_in[0].position, tes_in[0].normal);\n\n    vertices[1][1] = calcVertex3(tes_in[2].position, tes_in[2].normal, tes_in[3].position, tes_in[3].normal, tes_in[0].position, tes_in[0].normal);\n\n    vec3 vert1 = calcBezierSample3(vertices[0][0], vertices[0][1], vertices[0][2], u);\n    vec3 vert2 = calcBezierSample3(vertices[1][0], vertices[1][1], vertices[1][2], u);\n    vec3 vert3 = calcBezierSample3(vertices[2][0], vertices[2][1], vertices[2][2], u);\n    tes_out.position = calcBezierSample3(vert3, vert2, vert1, v);\n}"

#define model_gs "#version 450\n\nlayout (triangles) in;\nlayout (triangle_strip, max_vertices = 3) out;\n\nin TES_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} gs_in[];\n\nout GS_OUT {\n    vec3 position;\n    vec3 normal;\n    vec2 texCoord;\n} gs_out;\n\nuniform mat4 gProj;\n\nvoid main() {\n    mat4 gProj_T = transpose(gProj);\n\n    gl_Position = gProj_T * (vec4(gs_in[0].position, 1.0f));\n    gs_out.position = gs_in[0].position;\n    gs_out.normal = gs_in[0].normal;\n    gs_out.texCoord = gs_in[0].texCoord;\n    EmitVertex();\n\n    gl_Position = gProj_T * (vec4(gs_in[1].position, 1.0f));\n    gs_out.position = gs_in[1].position;\n    gs_out.normal = gs_in[1].normal;\n    gs_out.texCoord = gs_in[1].texCoord;\n    EmitVertex();\n\n    gl_Position = gProj_T * (vec4(gs_in[2].position, 1.0f));\n    gs_out.position = gs_in[2].position;\n    gs_out.normal = gs_in[2].normal;\n    gs_out.texCoord = gs_in[2].texCoord;\n    EmitVertex();\n\n    EndPrimitive();\n}"
